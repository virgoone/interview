# 垃圾回收

[[toc]]

[toc]

JavaScript 是使用垃圾回收的语言，也就是说**执行环境负责在代码执行时管理内存**。

基本思路很简单：**确定哪个变量不会再使用，然后释放它的内存**。这个过程是**周期性**的，即垃圾回收程序每隔一段时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行。

垃圾回收过程是一个近似且不完美的方案，因为某块内存是否还有用，属于“**不可判定的**”问题，意味着靠算法是无法解决的。

## 常用变量标记策略

垃圾回收程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回收内存。如何标记未使用的变量也许有不同的实现方式，但在浏览器的发展历史上，用到过两种主要的标记策略：**标记清理**和**引用计数**。

### 标记清理

**JavaScript 最常用的垃圾回收策略是标记清理**（mark-and-sweep）。

在变量**进入上下文**（比如在函数内部声明一个变量时），变量会被**加上存在于上下文中的标记**。而不在上下文中的变量（全局变量），逻辑上讲，永远不应该释放它们的内存。

#### 变量加标记方式(不重要)

1. 变量进入上下文时，反转某一位
2. 维护“在上下文中”和“不在上下文中”两个列表，进行对应的变量转移

#### 标记清理策略

1. 垃圾回收程序运行的时候，会**标记内存中存储的所有变量**
2. 将**所有在上下文中的变量**以及**被在上下文中的变量引用的变量**的**标记去掉**，剩下还有标记的就是待删除的变量，因为在任何上下文中的变量都不会访问他们
3. 垃圾回收程序再做一次**内存清理**，**销毁带标记的所有值**并回收他们的内存

### 引用计数 

**引用计数的思路是对每个值都记录它被引用的次数**，当一个值的引用数为 0 时，就说明没法再访问到这个值了，因此就可以安全地收回内存了。

#### 严重问题：循环引用

循环引用，就是对象 A 有一个指针指向了对象 B，而同时对象 B 也有一个指针指向了对象 A。

```ts
function problem() {
    let objectA = new Object()
    let objectB = new Object()
    
    objectA.someOtherObject = objectB
    objectB.anotherObject = objectA
}
```

这里 `objectA` 和 `objectB` 通过各自属性的互相引用，引用数都为 2，但在函数结束后，二者都不在作用域中，而在引用计数策略下，二者占用的内存都不会释放。

##### 解决方法

在 IE8 及更早的版本中，BOM 和 DOM 不是 JS 的原生对象，而是组件对象模型 COM（Component Object Model），其使用引用计数实现垃圾回收。

为避免类似的循环引用问题，应该确保不使用的情况下切断原生 JavaScript 对象与 DOM 元素之间的连接，如：把变量设置为 `null` 实际上会切断变量与之前引用值之间的关系。





## 垃圾回收的时间点

垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能会造成性能损失，因此**垃圾回收的时间调度**很重要。

现代垃圾回收程序**基于对 JavaScript 运行时环境的探测**来决定何时运行。探测机制因引擎而异，但基本上都是**根据已分配对象的大小和数量来判断的**。比如 V8：“在一次完整的垃圾回收之后，V8 的堆增长策略会根据活跃对象的数量外加一些余量来确定何时再次垃圾回收”。

## 内存管理

1. **解除引用**：如果数据不再必要，就把它设置为 `null`，释放其引用。
2. **通过 const 和 let 声明提升性能**：相比于使用 `var`，使用这两个新关键字可能会更早的**让垃圾回收程序介入**，尽早回收应该回收的内存。
3. **隐藏类和删除操作**
4. **静态分配和对象池**:在初始化的某一时刻，创建一个**对象池**，用来管理一组可回收的对象。

### 内存泄漏

##### 意外的全局变量声明

```js
function setName() {
    name = 'Atchoo'
}
```

##### 定时器

```js
let name = "Atchoo"
setInterval(() => {
    console.log(name)
},100)
```

只要定时器一直运行，回调函数中引用的 `name` 就会一直占用内存。垃圾回收程序当然知道这一点，因而就不会清理外部内存。

##### 闭包

使用 JavaScript 闭包很容易在不知不觉间造成内存泄漏。

```js
let outer = function() {
    let name = 'Atchoo'
    return function() {
        return name
    }
}
```

这会导致分配给 `name` 的内存被泄漏。以上代码创建了一个内部闭包，只要 `outer` 函数存在就不能清理 `name`，因为闭包一直在引用着它。假如 `name` 的内容很大，那就可能是个大问题了。

## V8 引擎的内存管理与垃圾回收

### 内存分类

* 栈：简单说，栈内存，**小且存储连续**，操作起来简单方便，**一般由系统自动分配，自动回收**，所以文章内所说的垃圾回收，都是基于堆内存。
* 堆：堆内存，**大(相对栈来说)且不连续**。

#### V8 中内存分类中的弱分代假说

在讲内存分配之前，先了解一下弱分代假说，V8 的垃圾回收主要建立在这个假说之上。

概念：
* **绝大部分的对象生命周期都很短，即存活时间很短**
* **生命周期很长的对象，基本都是常驻对象**

基于以上两个概念，将内存分为**新生代 (new space)与老生代 (old space)**两个区域。划重点，记一下。

![图片](https://tva1.sinaimg.cn/large/0081Kckwgy1glxucvalkoj31qs0jydin.jpg)

### V8 的垃圾回收

#### 新生代

**新生代**(32 位系统分配 16M 的内存空间，64 位系统翻倍 32M，不同浏览器可能不同，但是应该差不了多少)。

新生代对应存活时间很短的假说概念，这个空间的操作，非常频繁，绝大多数对象在这里经历一次生死轮回，基本消亡，没消亡的会晋升至老生代内。

新生代算法为 Scavenge 算法，典型牺牲空间换时间。首先他将新生代分为两个相等的半空间( semispace ) **from space** 与 **to space**，来看看这个败家玩意，是怎么操作的，他使用广度优先算法，是广度优先，记住了不。两个空间，同一时间内，**只会有一个空间在工作( from space )**，**另一个在休息( to space )**。

1. 首先，V8 引擎中的垃圾回收器检测到 from space 空间快达到上限了，此时要进行一次垃圾回收了
2. 然后，从根部开始遍历，**不可达对象(即无法遍历到的对象)将会被标记**，并且复制未被标记的对象，放到 to space 中
3. 最后，**清除 from space 中的数据**，同时将 from space 置为空闲状态，即变成 to space，相应的 to space 变成 from space，俗称**翻转**

这么来一次，虽然浪费了一半空间，但是问题不大，因为节省了很多时间。

当然优秀的 V8 是不可能容忍，一个对象来回的在 form space 和 to space 中蹦跶的，**当经历一次 form => to 翻转之后，发现某些未被标记的对象居然还在，会直接扔到老生代里面去**。

除了上面一种情况，还有一个情况也会晋级，当一个对象，**在被复制的时候，大于 to space 空间的 25% 的时候，也会晋级**，直接晋级到老生代。

#### 老生代

**老生代**( 32 位操作系统分配大约 700M 内存空间，64 位翻倍 1.4G，一样，每个浏览器可能会有差异，但是差不了多少)。

老生代比起新生代可是要复杂的多，所谓能者多劳，空间大了，责任就大了，老生代可以分为以下几个区域：

* **old object space**：即大家口中的老生代，不是全部老生代，这里的对象**大部分是由新生代晋升而来**
* **large object space**：**大对象存储区域**，其他区域无法存储下的对象会被放在这里，基本是超过 1M 的对象，这种对象不会在新生代对象中分配，直接存放到这里，当然了，这么大的数据，复制成本很高，基本就是在这里等待命运的降临。
* **Map space**：这个玩意，就是**存储对象的映射关系**的，其实就是**隐藏类**。
* **code space**：简单点说，就是**存放编译之后的代码**。

##### 老生代回收算法

讲了这么多基本概念，聊聊最后的老生代回收算法，老生代回收算法为：**标记**和**清除/整理**（mark-sweep/mark-compact）。

在标记的过程中，引入了概念：**三色标记法**，三色为：

* 白：**未被标记的对象**，即不可达对象（没有扫描到的对象），**可回收**
* 灰：**已被标记的对象**（可达对象），但是对象还没有被扫描完，**不可回收**
* 黑：**已被扫描完**（可达对象），**不可回收**

当然，既然要标记，就需要提供记录的坑位，在 V8 中分配的每一个内存页中创建了一个 **marking bitmap**。

大致的流程为：

1. 首先将所有的**非根部对象全部标记为白色**，然后使用**深度优先遍历**，是深度优先哈，和新生代不一样哈，按深度优先搜索沿途遍历，将访问到的对象，直接压入栈中，同时**将标记结果放在 marking bitmap (灰色) 中**，一个对象遍历完成，直接**出栈**，同时在 **marking bitmap 中记录为黑色**，直到栈空为止
2. 标记完成后，接下来就是等待垃圾回收器来清除了，清除完了之后，**会在原来的内存区域留下一大堆不连续的空间**，如果来一个稍微大一点的对象，没有内存可以放的下
3. 所以在清除完之后，新生代中对象，再一次分配到老生代并且**内存不足**的时候，会优先触发**标记整理**（mark-compact）, 在标记结束后，他会**将可达对象(黑色)，移到内存的另一端**，其他的内存空间就不会被占用，直接释放，等下次再有对象晋升的时候，轻松放下。

### 写屏障

想一个问题，当 GC 想回收新生代中的内容的时候，某些对象，只有一个指针指向了他，好巧不巧的是，这个指针还是老生代那边对象指过来的，怎么搞？我想回收这个玩意，难道要遍历一下老生代中的对象吗？这不是开玩笑吗？为了回收这一个玩意，我需要遍历整个老生代，代价着实太大，搞不起，搞不起，那怎么办哩？

V8 引擎中有个概念称作**写屏障**，在写入对象的地方有个**缓存列表**，这个列表内**记录了所有老生代指向新生代的情况**，当然了新生成的对象，并不会被记录，只有老生代指向新生代的对象，才会被写入这个缓存列表。

在新生代中触发 GC 遇到这样的对象的时候，会首先读一下缓存列表，这相比遍历老生代所有的对象，代价实在是太小了，当然了，关于 V8 引擎内在的优化，还有很多很多，各位大佬可以慢慢去了解。

### 全停顿（stop-the-world）

在以往，新/老生代都包括在内，为了防止逻辑和垃圾回收的情况不一致，需要停止 JS 的运行，专门来遍历去遍历/复制，标记/清除，这个停顿就是：**全停顿**。

这就比较恶心了，新生代也就算了，本身内存不大，时间上也不明显，但是在老生代中，如果遍历的对象太多，太大，用户在此时，是有可能明显感到页面卡顿的，体验很差。

所以在 V8 引擎在名为 Orinoco 项目中，做了三个事情，当然只针对老生代，新生代这个后浪还是可以的，效率贼拉的高，优化空间不大。三个事情分别是：

#### 增量标记

将原来一口气去标记的事情，做成分步去做，每次**内存占用达到一定的量或者多次进入写屏障的时候**，就**暂时停止 JS 程序**，**做一次最多几十毫秒的标记 marking**，当下次 GC 的时候，反正前面都标记好了，开始清除就行了

#### 并行回收

从字面意思看并行，就是在一次全量垃圾回收的过程中，就是 V8 引擎通过**开启若干辅助线程，一起来清除垃圾**，可以极大的减少垃圾回收的时间

#### 并发回收

并发就是在 JS 主线程运行的时候，**同时开启辅助线程，清理和主线程没有任何逻辑关系的垃圾**，当然，需要**写屏障**来保障

### 其他

V8 引擎做的优化有很多，还有比如**多次( 2 次)在新生代中能够存活下来的对象**，会被记录下来，在下次 GC 的时候，会被**直接晋升到老生代**，还有比如**新晋升的对象，直接标记为黑色**，这是因为新晋升的对象存活下来的概率非常高，这两种情况就算是不再使用，再下下次的时候也会被清除掉，影响不大，但是这个过程，第一种就省了新生代中的一次复制轮回，第二种就省了 marking 的过程，在此类对象比较多的情况下，还是比较有优势的。