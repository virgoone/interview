# 网络相关

## 网络基础

### 1. 讲述一下 OSI 的七层网络模型

| OSI 七层模型 | 对应协议  |
| ------------ | --------- |
| 应用层       | HTTP、FTP |
| 表示层       |           |
| 会话层       | DNS       |
| 传输层       | TCP、UDP  |
| 网络层       | IP、ICMP  |
| 数据链路层   |           |
| 物理层       |           |

### 2. TCP/IP 协议的四层网络模型是怎样的

| 层级       | 作用                           | 协议      |
| ---------- | ------------------------------ | --------- |
| 应用层     | 直接为进程提供服务             | HTTP、FTP |
| 传输层     | 为两台主机中的进程提供通信服务 | TCP、UDP  |
| 网络层     | 进行 IP 地址的封装和解封装     | IP        |
| 数据链路层 | 进行 MAC 地址的封装和解封装    |           |

## TCP

### 1. TCP 协议是怎么保证可靠传输的

TCP 是一种提供可靠性交付的协议。 也就是说，通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。 TCP 是通过下面几个特性保证数据传输的可靠性：<br />

- **序列号和确认应答信号**
- **超时重发控制**
- **连接管理**
- **滑动窗口控制**
- **流量控制**
- **拥塞控制**

### 2. 简述 TCP 的三次握手

1. **由客户端发出请求连接**，报文情况是： **SYN=1**，**ACK=0**，**seq=x**。按照规定，SYN=1 时不能携带数据，但要消耗一个序号，所以和 SYN 一起抵达战场的还有一个**记录序号的 seq，其值为 x**。
1. 然后**服务端进行回复确认**，报文内容是：**SYN=1**，**ACK=1**，同时还有**服务端为自己初始化的序号** **seq=y**,   以及**确认号 ack=x+1**
1. 再然后**客户端再进行一次确认**，这一步用不到 SYN 了，报文内容是：**ACK=1**, **seq=x+1**, **ack=y+1**。

#### 2.1 为什么要进行三次握手

三次握手的目的是建立可靠的通讯通道。也就是数据的发送和接收。换言之，三次握手的目的就是**双方**确认自己与对方的发送和接收是正常的。

### 3. TCP 与 UDP 的区别

|     TCP      |      UDP       |
| :----------: | :------------: |
|   面向连接   |     无连接     |
|  面向字节流  |   面向数据报   |
|    有状态    |     无状态     |
| 保证可靠交付 | 不保证可靠交付 |
| 具备拥塞控制 | 不具备拥塞控制 |
|  点对点传播  |   广播、多播   |
|     有序     |      无序      |

### 4. TCP 是如何进行流量控制的

TCP 拥塞控制主要有两种。

- 第一种是**滑动窗口**，保证以一定的速度传输数据，主要是方式数据丢包等问题。
- 第二种是**拥塞处理**，主要是防止网络中的数据太过多，造成网络拥塞等问题。

<br />

## HTTP

### 1. HTTP 是什么

**HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。**

HTTP 通常跑在 **TCP/IP** 协议栈之上，依靠 **IP 协议实现寻址和路由**、**TCP 协议实现可靠数据传输**、**DNS 协议实现域名查找**、**SSL/TLS 协议实现安全通信**。当然，WebSocket、HTTPDNS 依赖于 HTTP。

- HTTP 协议构建于 TCP/IP 协议之上，是一个应用层协议，默认端口号是 80
- HTTP 是无连接无状态的

### 2. HTTP/1 和 HTTP/2 的区别

HTTP 2.0 相比于 HTTP 1.X，可以说是**大幅度提高了 web 的性能**。<br />

- **二进制分帧**：HTTP 1.x 中，数据以文本的格式进行传输，解析起来比较低效。HTTP/2 传输消息时，首先会将消息划分为更小的信息和帧，然后再对其采取**二进制格式**的编码，确保高效的解析。
- **多路复用**：就是在**一个 TCP 连接中可以存在多条流**。也就是说，可以发送多条请求，对端可以**通过帧中的标识知道其属于哪个请求（流）**，从而解决旧版本的**队头堵塞**问题，极大提高传输性能。
- **Header 压缩**：在 HTTP 1.x 中，我们使用**文本**的形式传输 header。在 HTTP/2.0 中，使用了 **HPACK 压缩格式**对传输的 header 进行编码，减少了 header 的大小。
- 服务端 Push：在 HTTP1.x 中，如果用户请求了资源 A，结果发现自己如果要用资源 A，那么必须依赖资源 B，这时他不得不再消耗一个请求。而在 HTTP/2.0 中，服务端在收到某个请求后，允许**服务端主动向客户端 push 资源**。

### 3. 简单讲解一下 HTTP/2 中的多路复用

> HTTP/2 **复用 TCP 连接**，在一个连接里，客户端和浏览器都可以**同时发送多个请求或回应**而且不用按照顺序一一对应

为了解决两个效率问题：

1. 串行的文件传输
2. 连接数过多

HTTP/2 中有两个重要概念，分别是**帧（frame）**和**流（stream）**。**帧代表着最小的数据单位**，每个帧会标识出其所属的流，**流则由多个帧组成**。<br />多路复用，就是在**一个 TCP 连接中可以存在多条流**。也就是说，可以发送多条请求，对端可以**通过帧中的标识知道其属于哪个请求（流）**，从而解决旧版本的**队头堵塞**问题，极大提高传输性能。<br />

### 4. HTTPS 的 TLS 的四次握手

- Client 发起一个 HTTPS（比如`[https://juejin.im/user/5a9a9cdcf265da238b7d771c](https://juejin.im/user/5a9a9cdcf265da238b7d771c)`）的请求，根据 RFC2818 的规定，Client 知道需要连接 Server 的 443（默认）端口。
- Server 把事先配置好的公钥证书（public key certificate）返回给客户端。
- Client 验证公钥证书：比如是否在有效期内，证书的用途是不是匹配 Client 请求的站点，是不是在 CRL 吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的 Root 证书或者 Client 内置的 Root 证书）。如果验证通过则继续，不通过则显示警告信息。
- Client 使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给 Server。
- Server 使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client 和 Server 双方都持有了相同的对称密钥。
- Server 使用对称密钥加密“明文内容 A”，发送给 Client。
- Client 使用对称密钥解密响应的密文，得到“明文内容 A”。
- Client 再次发起 HTTPS 的请求，使用对称密钥加密请求的“明文内容 B”，然后 Server 使用对称密钥解密密文，得到“明文内容 B”。

### 5. 一次完整的 HTTP 事务是怎样的一个过程 ？

- 域名解析
- 发起 TCP 的 3 次握手
- 建立 TCP 连接后发起 http 请求
- 服务器响应 http 请求，浏览器得到 html 代码
- 浏览器解析 html 代码，并请求 html 代码中的资源（如 js、css、图片等）
- 浏览器对页面进行渲染呈现给用户

### 5. HTTP/1.0 中的 Keep-Alive 和 HTTP/1.1 中的保持长连接的区别

- HTTP/1.0 中，要保持长连接，需要在请求头里带上 `Connection: Keep-Alive` ，并在后续请求中始终保持
- HTTP/1.1 中，默认开启持久连接，只要浏览器或者服务器没有断开连接，该 TCP 会一直保持，如果需要关闭，则在请求头中带上  `Connection: Close`

### 6. HTTP/1.1 中的管线化与 HTTP/2 中的多路复用的区别？

- HTTP/1.1 中，允许多个 HTTP 请求批量提交给服务器（要按顺序）
  - 解决了**队头堵塞（**达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求**）**的问题，HTTP/1.0 中请求与请求间是串行的
- 但具有一定的**局限性**，因为无法从源头解决队头堵塞问题，发送动作并行，但响应仍是串行的
- HTTP/2 中引入多路复用，就是在**一个 TCP 连接中可以存在多条流**。也就是说，可以发送多条请求，对端可以**通过帧中的标识知道其属于哪个请求（流）**，从而解决旧版本的**队头堵塞**问题，极大提高传输性能（不需要按顺序）

#### 6.1 为什么 HTTP/1.1 不能实现多路复用

**HTTP/1.1 不是二进制传输，而是通过文本进行传输**。由于没有流的概念，在使用并行传输（多路复用）传递数据时，接收端在接收到响应后，并不能区分多个响应分别对应的请求，所以无法将多个响应的结果重新进行组装，也就实现不了多路复用。

### 7. HTTP request 的报文结构是什么样的

1. 首行是**请求行 Request-Line **包括：**请求方法**，**请求 URI**，**协议版本**
1. 首行之后是若干行**请求头**，包括**通用首部** **general-header**，**请求首部** **request-header**或者**实体首部** **entity-header**
1. 根据实际请求需要可能包含一个**消息实体**

#### 7.1 HTTP response 的报文结构是什么样的

- 首行是**响应\*\***行 \***\*Request-Line\*\*** **包括：**HTTP 版本**，**状态码**，**状态描述\*\*
- 首行之后是若干行**响应头**，包括**通用首部** **general-header**，响应**首部** **response-header**或者**实体首部** **entity-header**
- 之后是一个可能的**消息实体**

### 8. 怎么理解 HTTP 协议的“无状态”？

无状态可以理解为**无记忆**，即两个请求之间不关心彼此的情况，没有任何关系。

#### 8.1 如何维持 HTTP 的状态信息？

- **使用 cookie**：cookie 是存储在浏览器的小段文本，会在浏览器每次向同一服务器再发起请求时被携带并发送到服务器上。我们可以把状态信息放在 cookie 里，带给服务器。
- **使用 session**：session 是存储在服务器的用户数据。浏览器第一次向服务器发起请求时，服务器会为当前会话创建一个 session，并且把对应的 session-id 写入 cookie 中，用来标识 session。此后，每次用户的请求都会携带一个包含了 session-id 的 cookie，服务器解析出了 session-id，便能定位到用户的用户信息。

## 其他

### 1. 说一说你对 CDN 的理解？

**CDN（Content Delivery Network）**就是内容分发网络。<br />为了突破现实生活中的光速、传输距离等物理限制，CDN 投入了大量资金，在全球范围内各大枢纽城市建立机房，部署大量高存储高带宽的节点，构建跨运营商、跨地域的专用高速传输网络。<br />其中分为中心节点、区域节点、边缘节点等，在用户接入网络后，首先通过**全局负载均衡** (Global Sever Load Balance)，简称 GSLB 算法负责调度，找到离用户最合适的节点。然后通过 HTTP 缓存代理技术进行缓存，缓存命中就返回给用户，否则就回源站去取。CDN 擅长缓存静态资源(图片、音频等)，当然也支持动态内容的缓存。<br />

### 2. 说一说你对 WebSocket 的理解？

**WebSocket** 是一种基于 TCP 的轻量级网络通信协议。和 HTTP/2 一样，都是为了解决 HTTP 某些方面的缺陷而诞生的。不过解决方式略有不同，**HTTP/2 针对的是“队头阻塞 ”**，**WebSocket 针对的是“请求-应答”的通信模式**。

我们知道“请求-应答”是半双工的通信模式，不具备服务器推送能力。这就限制了 HTTP 在实时通信领域的发展。虽然可以使用轮询来不停的向服务器发送 HTTP 请求，但是缺点也很大，反复的无效请求占用了大量的带宽和 CPU 资源。所以，WebSocket 应运而生。

WebSocket 是一个全双工通信协议，具备服务端主动推送的能力。**本质上是对 TCP 做了一层包装，让它可以运行在浏览器环境里**。

### 3. 说一下对 DNS 的理解

DNS (Domain Name System) 是互联网中的重要基础设施，负责对域名的解析工作，为了保证高可用、高并发和分布式，它设计成了树状的层次结构。

DNS 系统由根 DNS 服务器、顶级域 DNS 服务器和权威 DNS 服务器组成。解析时按照 DNS 解析顺序层层查找。还可以基于域名在内网、外网进行负载均衡。

不过传统的 DNS 有很多问题(解析慢、更新不及时)，HTTPDNS 通过客户端 SDK 和服务端配合，直接通过 HTTP 调用解析 DNS 的方式，可以绕过传统 DNS 这些缺点，实现智能调度。

#### 3.1 说一下 DNS 的解析顺序

1. **浏览器缓存**
2. **操作系统缓存**
3. **本地 DNS 缓存** (/etc/hosts)
4. **本地 DNS 服务器**
5. **根 DNS 服务器**
6. **顶级 DNS 服务器**
7. **权威 DNS 服务器**。

### 4. 说下 websocket 和 socket 的区别

软件通信有七层结构，下三层结构偏向与数据通信，上三层更偏向于数据处理，中间的传输层则是连接上三层与下三层之间的桥梁，每一层都做不同的工作，上层协议依赖与下层协议。基于这个通信结构的概念。

**Socket 其实并不是一个协议，是应用层与 TCP/IP 协议族通信的中间软件抽象层，它是一组接口。**当两台主机通信时，让 Socket 去组织数据，以符合指定的协议。TCP 连接则更依靠于底层的 IP 协议，IP 协议的连接则依赖于链路层等更低层次。

WebSocket 则是一个典型的应用层协议。

在计算机通信领域，socket 被翻译为“套接字”，它是计算机之间进行**通信**的**一种约定**或一种方式。通过 socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。

### 浏览器的三级缓存策略了解吗

1. 先在内存中查找，如果有就加载
1. 如果内存中不存在，则在硬盘中查找，如果有就加载
1. 如果硬盘中也没有，那么就进行网络请求
1. 请求获取的资源缓存到硬盘和内存

### 浏览器缓存有哪些及执行顺序

浏览器缓存分为**强缓存**和**协商缓存**，强缓存会直接从浏览器里面拿数据，协商缓存会先访问服务器看缓存是否过期，再决定是否从浏览器里面拿数据。<br />
<br />控制强缓存的字段有：Expires 和 Cache-Control<br />控制协商缓存的字段是：Last-Modified / If-Modified-Since 和 Etag / If-None-Match，其中 Etag / If-None-Match 的优先级比 Last-Modified / If-Modified-Since 高。<br />
<br />`Cache-Control: no-cach`不会缓存数据到本地的说法是错误的<br />`Cache-Control: no-store`才是真正的不缓存数据到本地<br />`Cache-Control: public`可以被所有用户缓存（多用户共享），包括终端和 CDN 等中间代理服务器<br />`Cache-Control: private`只能被终端浏览器缓存（而且是私有缓存），不允许中继缓存服务器进行缓存<br />
<br />大致的顺序：

- Cache-Control —— 请求服务器之前
- Expires —— 请求服务器之前
- If-None-Match (Etag) —— 请求服务器
- If-Modified-Since (Last-Modified) —— 请求服务器

<br />

状态码：

<br />

- `200`：强缓 Expires/Cache-Control 存失效时，返回新的资源文件
- `200(from cache)`: 强缓 Expires/Cache-Control 两者都存在，未过期，Cache-Control 优先 Expires 时，浏览器从本地获取资源成功
- `304(Not Modified )`：协商缓存 Last-modified/Etag 没有过期时，服务端返回状态码 304

<br />

### 页面从输入 URL 到最后展现中间步骤经历了什么

- 浏览器根据请求的 URL 交给 DNS 域名解析
- 通过网址，解析域名获取 IP 地址
- 三次握手建立 TCP 连接
- 发送 HTTP 请求
- 服务器处理请求并返回 HTTP 报文
- 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；
- 浏览器对加载到的资源（HTML、JS、CSS 等）进行语法解析，建立相应的内部数据结构（如 HTML 的 DOM）；
- 载入解析到的资源文件，渲染页面，完成。
- 四次挥手结束连接

<br />
