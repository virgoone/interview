# HTTP & HTTPS

## HTTP（超文本传输协议）

> **HTTP （HyperText Transfer Protocol）是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。**

HTTP **无状态**，可以理解为“无记忆”，即请求与请求之间无关联

### HTTP 请求方法

- **GET**：仅用作数据的**读取**（**幂等**），请求参数以 query 的形式附加
- **POST**：**创建新资源**或修改现有资源，请求参数以 body 的形式传递
- **HEAD**：**只请求页面的首部**，不请求页面内容。它允许单纯获取服务器的响应头信息
- **PUT**：与 POST 类似，区别是 PUT 的 URI 指向某个具体资源，而不能指向资源集合，且 PUT 对**资源的修改**是**幂等**的
- **DELETE**：用于删除指定的资源
- **OPTIONS**：用于获取指定服务器能攻支持的通信选项

#### Post 和 Get 的区别

先引入**副作用**和**幂等**的概念。

副作用指**对服务器上的资源做改变**，搜索是无副作用的，注册是副作用的。

幂等指**发送 M 和 N 次请求（两者不相同且都大于 1）**，**服务器上资源的状态一致**，比如注册 10 个和 11 个帐号是不幂等的，对文章进行更改 10 次和 11 次是幂等的。

在规范的应用场景上说，**Get 多用于无副作用，幂等的场景**，例如搜索关键字。**Post 多用于副作用，不幂等的场景**，例如注册。

在技术上说：

- Get 请求能缓存，Post 不能
- Post 相对 Get 安全一点点，因为 Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会，但是在抓包的情况下都是一样的。
- Post 可以通过 request body 来传输比 Get 更多的数据，Get 没有这个技术
- URL 有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的
- Post 支持更多的编码类型且不对数据类型限制

### HTTP 状态码

#### 1xx

1xx 的状态码表示**成功接收了请求，但处理流程还没结束，需要客户端再抛出一个请求才能完成整个过程**

#### 2xx 成功

2xx 的状态码表示**成功接受请求并已处理完毕**

| 状态码 | 说明 | 作用                           |
| ------ | ---- | ------------------------------ |
| 200    | OK   | 客户端的请求已被服务器正确处理 |

#### 3xx 重定向

3xx 的状态码表示**服务器虽然处理了请求，但客户端还需要进一步的工作才可以完成请求**

| 状态码 | 说明               | 作用                                                                                                               |
| ------ | ------------------ | ------------------------------------------------------------------------------------------------------------------ |
| 301    | Moved Permanently  | 永久重定向，表示资源已被分配了新的 URL                                                                             |
| 302    | See Other          | 临时重定向，表示资源被临时分配了新的 URL                                                                           |
| 304    | Not Modified       | 表示服务器允许访问资源，但因发生请求未满足条件的情况，即服务器校验后发现资源没有改变，提醒客户端直接走缓存来取资源 |
| 307    | Temporary Redirect | 临时重定向，和 302 含义类似，但是期望客户端保持请求方法不变向新的地址发出请求                                      |

#### 4xx 客户端错误

4xx 的状态码表示**客户端错误，意味着请求出错了**

| 状态码 | 说明         | 作用                                                     |
| ------ | ------------ | -------------------------------------------------------- |
| 400    | Bad Request  | 请求报文出现语法错误                                     |
| 401    | Unauthorized | 表示发送的请求需要有通过 HTTP 认证的认证信息             |
| 403    | Forbidden    | 对请求资源的访问被服务器拒绝                             |
| 404    | Not Found    | 在服务器上没有找到请求的资源，可能是路径不对或者资源没了 |

#### 5xx 服务器错误

5xx 的状态码表示**服务器错误，服务器内部的程序处理有问题**

| 状态码 | 说明                  | 作用                                               |
| ------ | --------------------- | -------------------------------------------------- |
| 500    | Internal Server Error | 服务器在接受请求后进行处理的过程中，发生了内部错误 |
| 501    | Not Implemented       | 表示服务器不支持当前请求所需要的某个功能           |
| 502    | ---                   | 网关错误                                           |
| 503    | Service Unavailable   | 服务器暂时处于超负载或正在停机维护，无法处理请求   |
| 504    | ---                   | 网关超时                                           |

### HTTP 报文

#### 请求/响应行

请求行：

- HTTP 版本
- HTTP 请求方法
- URI

状态行：

- HTTP 版本
- 状态码

#### 报文首部

|   请求报文   |   响应报文   |
| :----------: | :----------: |
| 请求首部字段 | 响应首部字段 |
| 通用首部字段 | 通用首部字段 |
| 实体首部字段 | 实体首部字段 |

##### 通用首部字段

![通用首部字段](https://tva1.sinaimg.cn/large/0081Kckwgy1gl8fwvewtbj31830u044b.jpg)

##### 请求首部字段

![请求首部字段](https://tva1.sinaimg.cn/large/0081Kckwgy1gl8fx0xmfpj30u00vu43y.jpg)

##### 响应首部字段

<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl8fx4ghkgj30qq0dkjsf.jpg" alt="响应首部字段" style="zoom:67%;" />

##### 实体首部字段

<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl8fx9pmrnj30sm0hs75z.jpg" alt="实体首部字段" style="zoom:67%;" />

### HTTP 版本演进

#### HTTP/1.1

1. **实现长连接**：通过**一个 TCP 连接里可以进行多次 HTTP 通信**解决了**TCP 连接不可复用**的问题
2. **管线化**：允许多个 HTTP 请求批量提交给服务器
   - 解决了**队头堵塞**的问题，HTTP/1.0 中请求与请求间是串行的
   - 但具有一定的**局限性**，因为无法从源头解决问题，发送动作并行，但响应仍是串行的

#### HTTP/2.0

HTTP 2.0 相比于 HTTP 1.X，可以说是**大幅度提高了 web 的性能**。

在 HTTP 1.X 中，为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为**浏览器限制了同一个域名下的请求数量**，当页面中需要请求很多资源的时候，**队头阻塞**（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。

##### 二进制分帧

HTTP 1.x 中，数据以文本的格式进行传输，解析起来比较低效，因此 HTTP/2.0 加强性能的核心点在此。传输消息时，首先会将消息划分为更小的信息和帧，然后再对其采取**二进制格式**的编码，确保高效的解析。

##### 多路复用

为了解决两个效率问题：

1. 串行的文件传输，**队头堵塞**的问题没有真正解决
2. 连接数过多

HTTP/2.0 中有两个重要概念，分别是**帧（frame）**和**流（stream）**。**帧代表着最小的数据单位**，每个帧会标识出其所属的流，**流则由多个帧组成**。

多路复用，就是在**一个 TCP 连接中可以存在多条流**。也就是说，可以发送多条请求，对端可以**通过帧中的标识知道其属于哪个请求（流）**，从而解决旧版本的**队头堵塞**问题，极大提高传输性能。

##### Header 压缩

在 HTTP 1.x 中，我们使用**文本**的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几十到上百字节。

在 HTTP/2.0 中，使用了 **HPACK 压缩格式**对传输的 header 进行编码，减少了 header 的大小。

并且，客户端和服务器会分别维护一份**相同的静态字典**，用来**存储常见的头部名称及头部名称和值的组合**，因此后面的请求只需要发送与之前的请求头部**不同**的地方，其他的头部信息都可以从字典中获取。

##### 服务端 Push

在 HTTP1.x 中，如果用户请求了资源 A，结果发现自己如果要用资源 A，那么必须依赖资源 B，这时他不得不再消耗一个请求。
而在 HTTP/2.0 中，服务端在收到某个请求后，允许**服务端主动向客户端 push 资源**。

## HTTPS

### 基础知识

#### HTTP 与 HTTPS 的区别

- HTTP 协议通常承载于 TCP 协议之上，在 HTTP 和 TCP 之间添加一个**安全协议层（SSL 或 TSL）**，这个时候，就成了我们常说的 HTTPS
- 默认 HTTP 的端口号为 80，HTTPS 的端口号为 443

#### 为什么 HTTPS 安全

因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而**如果使用 HTTPS，密钥在你和终点站才有**。

HTTPS 之所以比 HTTP 安全，是因为他**利用 SSL/TLS 协议传输**。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer 传递等。保障了传输过程的安全性

### TLS 协议加密

#### 相关概念

- **明文传输**：客户端发送请求，服务端发送响应，双方**都不对自己的请求/响应内容做加密**，一旦请求/响应被中间人拦截，就可以对其中的内容一览无余
- **对称加密**：客户端和服务器**约定一个共同的公钥**，加密和解密都依赖这个公钥，一旦公钥失窃，那么双方传输的密文信息就会暴露出来
- **非对称加密**：**公钥+私钥配合加密**，公钥与私钥是**多对一**的关系，公钥加密的内容，只有私钥能解开，私钥加密的内容，所有相关的公钥都可以解开，中间人截获了公钥也没办法解密数据，但**中间人可伪造公钥**
- **第三方认证**：第三方机构提供证书（Certificate Authority(CA)）
  - 包括：域名、公司信息、序列号、签名信息
  - 客户端里会维护一套**所有权威 CA 的公钥**用于解密
  - 客户端根据请求里证书的机构信息后，使用对应的公钥解析证书里的签名和服务器发来的公钥信息，用**解析的签名来校验对方的身份**，校验通过就使用公钥来进行通信

#### TLS 的四次握手

![image-20201113180036803](https://tva1.sinaimg.cn/large/0081Kckwgy1glx0yz8rotj317s0soaoy.jpg)

1. **客户端发送一个随机值**，需要的**协议和加密方式**
2. **服务端**收到客户端的随机值，自己也**产生一个随机值**，并根据客户端需求的**协议和加密方式**来使用对应的方式，**发送自己的证书**
3. **客户端**收到服务端的证书并**验证**是否有效，验证通过会再**生成一个随机值**，通过**服务端证书的公钥去加密这个随机值并发送给服务端**，如果服务端需要验证客户端证书的话会**附带证书**
4. **服务端**收到加密过的随机值并**使用私钥解密获得第三个随机值**，这时候**两端都拥有了三个随机值**，可以**通过这三个随机值按照之前约定的加密方式生成密钥**，接下来的通信就可以通过该密钥来加密解密

在 TLS 握手阶段，两端使用**非对称加密**的方式来通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用**对称加密**的方式通信
