# HTTP & HTTPS

## HTTP（超文本传输协议）

> **HTTP （HyperText Transfer Protocol）是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。**

HTTP **无状态**，可以理解为“无记忆”，即请求与请求之间无关联

### HTTP 请求方法

- **GET**：仅用作数据的**读取**（**幂等**），请求参数以 query 的形式附加
- **POST**：**创建新资源**或修改现有资源，请求参数以 body 的形式传递
- **HEAD**：**只请求页面的首部**，不请求页面内容。它允许单纯获取服务器的响应头信息
- **PUT**：与 POST 类似，区别是 PUT 的 URI 指向某个具体资源，而不能指向资源集合，且 PUT 对**资源的修改**是**幂等**的
- **DELETE**：用于删除指定的资源
- **OPTIONS**：用于获取指定服务器能攻支持的通信选项

#### Post 和 Get 的区别

先引入**副作用**和**幂等**的概念。

副作用指**对服务器上的资源做改变**，搜索是无副作用的，注册是副作用的。

幂等指**发送 M 和 N 次请求（两者不相同且都大于 1）**，**服务器上资源的状态一致**，比如注册 10 个和 11 个帐号是不幂等的，对文章进行更改 10 次和 11 次是幂等的。

在规范的应用场景上说，**Get 多用于无副作用，幂等的场景**，例如搜索关键字。**Post 多用于副作用，不幂等的场景**，例如注册。

在技术上说：

- Get 请求能缓存，Post 不能
- Post 相对 Get 安全一点点，因为 Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会，但是在抓包的情况下都是一样的。
- Post 可以通过 request body 来传输比 Get 更多的数据，Get 没有这个技术
- URL 有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的
- Post 支持更多的编码类型且不对数据类型限制

### HTTP 状态码

#### 1xx

1xx 的状态码表示**成功接收了请求，但处理流程还没结束，需要客户端再抛出一个请求才能完成整个过程**

#### 2xx 成功

2xx 的状态码表示**成功接受请求并已处理完毕**

| 状态码 | 说明 | 作用                           |
| ------ | ---- | ------------------------------ |
| 200    | OK   | 客户端的请求已被服务器正确处理 |

#### 3xx 重定向

3xx 的状态码表示**服务器虽然处理了请求，但客户端还需要进一步的工作才可以完成请求**

| 状态码 | 说明               | 作用                                                                                                               |
| ------ | ------------------ | ------------------------------------------------------------------------------------------------------------------ |
| 301    | Moved Permanently  | 永久重定向，表示资源已被分配了新的 URL                                                                             |
| 302    | See Other          | 临时重定向，表示资源被临时分配了新的 URL                                                                           |
| 304    | Not Modified       | 表示服务器允许访问资源，但因发生请求未满足条件的情况，即服务器校验后发现资源没有改变，提醒客户端直接走缓存来取资源 |
| 307    | Temporary Redirect | 临时重定向，和 302 含义类似，但是期望客户端保持请求方法不变向新的地址发出请求                                      |

#### 4xx 客户端错误

4xx 的状态码表示**客户端错误，意味着请求出错了**

| 状态码 | 说明         | 作用                                                     |
| ------ | ------------ | -------------------------------------------------------- |
| 400    | Bad Request  | 请求报文出现语法错误                                     |
| 401    | Unauthorized | 表示发送的请求需要有通过 HTTP 认证的认证信息             |
| 403    | Forbidden    | 对请求资源的访问被服务器拒绝                             |
| 404    | Not Found    | 在服务器上没有找到请求的资源，可能是路径不对或者资源没了 |

#### 5xx 服务器错误

5xx 的状态码表示**服务器错误，服务器内部的程序处理有问题**

| 状态码 | 说明                  | 作用                                               |
| ------ | --------------------- | -------------------------------------------------- |
| 500    | Internal Server Error | 服务器在接受请求后进行处理的过程中，发生了内部错误 |
| 501    | Not Implemented       | 表示服务器不支持当前请求所需要的某个功能           |
| 502    | ---                   | 网关错误                                           |
| 503    | Service Unavailable   | 服务器暂时处于超负载或正在停机维护，无法处理请求   |
| 504    | ---                   | 网关超时                                           |

### HTTP 报文

#### 请求/响应行

请求行：

- HTTP 版本
- HTTP 请求方法
- URI

状态行：

- HTTP 版本
- 状态码

#### 报文首部

|   请求报文   |   响应报文   |
| :----------: | :----------: |
| 请求首部字段 | 响应首部字段 |
| 通用首部字段 | 通用首部字段 |
| 实体首部字段 | 实体首部字段 |

##### 通用首部字段

![通用首部字段](https://tva1.sinaimg.cn/large/0081Kckwgy1gl8fwvewtbj31830u044b.jpg)

##### 请求首部字段

![请求首部字段](https://tva1.sinaimg.cn/large/0081Kckwgy1gl8fx0xmfpj30u00vu43y.jpg)

##### 响应首部字段

<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl8fx4ghkgj30qq0dkjsf.jpg" alt="响应首部字段" style="zoom:67%;" />

##### 实体首部字段

<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl8fx9pmrnj30sm0hs75z.jpg" alt="实体首部字段" style="zoom:67%;" />

### HTTP 版本演进

#### HTTP/1.1

1. **实现长连接**：通过**一个 TCP 连接里可以进行多次 HTTP 通信**解决了**TCP 连接不可复用**的问题
2. **管线化**：允许多个 HTTP 请求批量提交给服务器
   - 解决了**队头堵塞**的问题，HTTP/1.0 中请求与请求间是串行的
   - 但具有一定的**局限性**，因为无法从源头解决问题，发送动作并行，但响应仍是串行的

#### HTTP/2.0

HTTP 2.0 相比于 HTTP 1.X，可以说是**大幅度提高了 web 的性能**。

在 HTTP 1.X 中，为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为**浏览器限制了同一个域名下的请求数量**，当页面中需要请求很多资源的时候，**队头阻塞**（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。

##### 二进制分帧

HTTP 1.x 中，数据以文本的格式进行传输，解析起来比较低效，因此 HTTP/2.0 加强性能的核心点在此。传输消息时，首先会将消息划分为更小的信息和帧，然后再对其采取**二进制格式**的编码，确保高效的解析。

##### 多路复用

为了解决两个效率问题：

1. 串行的文件传输，**队头堵塞**的问题没有真正解决
2. 连接数过多

HTTP/2.0 中有两个重要概念，分别是**帧（frame）**和**流（stream）**。**帧代表着最小的数据单位**，每个帧会标识出其所属的流，**流则由多个帧组成**。

多路复用，就是在**一个 TCP 连接中可以存在多条流**。也就是说，可以发送多条请求，对端可以**通过帧中的标识知道其属于哪个请求（流）**，从而解决旧版本的**队头堵塞**问题，极大提高传输性能。

##### Header 压缩

在 HTTP 1.x 中，我们使用**文本**的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几十到上百字节。

在 HTTP/2.0 中，使用了 **HPACK 压缩格式**对传输的 header 进行编码，减少了 header 的大小。

并且，客户端和服务器会分别维护一份**相同的静态字典**，用来**存储常见的头部名称及头部名称和值的组合**，因此后面的请求只需要发送与之前的请求头部**不同**的地方，其他的头部信息都可以从字典中获取。

##### 服务端 Push

在 HTTP1.x 中，如果用户请求了资源 A，结果发现自己如果要用资源 A，那么必须依赖资源 B，这时他不得不再消耗一个请求。
而在 HTTP/2.0 中，服务端在收到某个请求后，允许**服务端主动向客户端 push 资源**。

### HTTP 缓存机制

缓存机制无处不在，有客户端缓存，服务端缓存，代理服务器缓存等。在 HTTP 中具有缓存功能的是浏览器缓存。 HTTP 缓存作为 web 性能优化的重要手段，对于从事 web 开发的朋友有重要的意义。

#### 缓存的规则

我们知道 HTTP 的缓存属于客户端缓存，后面会提到为什么属于客户端缓存。所以我们认为浏览器存在一个缓存数据库，用于储存一些不经常变化的静态文件（图片、css、js 等）。我们将缓存分为强制缓存和协商缓存。下面我将分别详细的介绍这两种缓存的缓存规则。

##### 强制缓存

当缓存数据库中已有所请求的数据时。客户端直接从缓存数据库中获取数据。当缓存数据库中没有所请求的数据时，客户端的才会从服务端获取数据。

![image-20201028213358871](https://tva1.sinaimg.cn/large/008eGmZEgy1gn5tczjqqxj31hb0kdwlk.jpg)

##### 协商缓存

又称对比缓存，客户端会先从缓存数据库中获取到一个缓存数据的标识，得到标识后请求服务端验证是否失效（新鲜），如果**没有失效服务端会返回 304**，此时客户端直接从缓存中获取所请求的数据，如果标识失效，服务端会返回更新后的数据。

![image-20201028213423994](https://tva1.sinaimg.cn/large/008eGmZEgy1gn5td34m28j31gq0hz46p.jpg)

###### 小贴士：

两类缓存机制可以同时存在，**强制缓存的优先级高于协商缓存**，当执行强制缓存时，如若缓存命中，则直接使用缓存数据库数据，不在进行缓存协商。

#### 缓存的方案

上面的内容让我们大概了解了缓存机制是怎样运行的，但是，服务器是如何判断缓存是否失效呢？

我们知道浏览器和服务器进行交互的时候会发送一些请求数据和响应数据，我们称之为 HTTP 报文。报文中包含首部 header 和主体部分 body。**与缓存相关的规则信息就包含在 header 中**。boby 中的内容是 HTTP 请求真正要传输的部分。举个 HTTP 报文 header 部分的例子如下：

<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn5td58uw8j30mh0a2q55.jpg" alt="image-20201028213450859" style="zoom:50%;" />

接下来我们将对 HTTP 报文中出现的与缓存规则相关的信息做出详细解释。（我们依旧分为强制缓存和协商缓存两个方面来介绍）

##### 强制缓存

对于强制缓存，服务器响应的 header 中会用两个字段来表明——**Expires** 和 **Cache-Control**。

###### Expires

Exprires 的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差，另一方面，Expires 是 HTTP1.0 的产物，故**现在大多数使用 Cache-Control 替代**。

###### Cache-Control

Cache-Control 有很多属性，不同的属性代表的意义也不同:

- **private**：客户端可以缓存
- **public**：客户端和代理服务器都可以缓存
- **max-age=t**：缓存内容将在 t 秒后失效
- **no-cache**：需要使用协商缓存来验证缓存数据
- **no-store**：所有内容都不会缓存。

##### 协商缓存

协商缓存需要进行对比判断是否可以使用缓存。

浏览器第一次请求数据时，**服务器会将缓存标识与数据**一起响应给客户端，客户端将它们备份至缓存中。

再次请求时，客户端会将**缓存中的标识发送给服务器**，服务器根据此标识判断。若未失效，返回 304 状态码，浏览器拿到此状态码就可以直接使用缓存数据了。 对于协商缓存来说，缓存标识我们需要着重理解一下，下面我们将着重介绍它的两种缓存方案。

###### Last-Modified

**Last-Modified**: 服务器在响应请求时，会告诉浏览器资源的最后修改时间。

**if-Modified-Since**: 浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有 if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回 304 和响应报文头，浏览器只需要从缓存中获取信息即可。 从字面上看，就是说：从某个时间节点算起，是否文件被修改了

1. 如果真的被修改：那么开始传输响应一个整体，服务器返回：200 OK
2. 如果没有被修改：那么只需传输响应 header，服务器返回：304 Not Modified

**if-Unmodified-Since**: 从字面上看, 就是说: 从某个时间点算起, 是否文件没有被修改

1. 如果没有被修改:则开始'继续'传送文件: 服务器返回: 200 OK
2. 如果文件被修改:则不传输,服务器返回: 412 Precondition failed (预处理错误)

这两个的区别是**一个是修改了才下载，一个是没修改才下载**。 Last-Modified 说好却也不是特别好，因为如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为 Last-Modified 时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，HTTP1.1 推出了 Etag。

###### Etag

**Etag**： 服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）

**If-None-Match**： 再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现 If-None-Match 则与被请求资源的唯一标识进行对比。

1. 不同，说明资源被改动过，则响应整个资源内容，返回状态码 200。
2. 相同，说明资源无新修改，则响应 header，浏览器直接从缓存中获取数据信息。返回状态码 304。

但是实际应用中由于 Etag 的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用 Etag 了。

#### 缓存的优点

1. 减少了冗余的数据传递，节省宽带流量
2. 减少了服务器的负担，大大提高了网站性能
3. 加快了客户端加载网页的速度 这也正是 HTTP 缓存属于客户端缓存的原因。

#### 不同刷新的请求执行过程

1. **浏览器地址栏中写入 URL，回车**：浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。（最快）
2. **F5**：F5 就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就胆胆襟襟的发送一个请求带上 If-Modify-since。
3. **Ctrl+F5**： 告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作。

## HTTPS

### 基础知识

#### HTTP 与 HTTPS 的区别

- HTTP 协议通常承载于 TCP 协议之上，在 HTTP 和 TCP 之间添加一个**安全协议层（SSL 或 TSL）**，这个时候，就成了我们常说的 HTTPS
- 默认 HTTP 的端口号为 80，HTTPS 的端口号为 443

#### 为什么 HTTPS 安全

因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而**如果使用 HTTPS，密钥在你和终点站才有**。

HTTPS 之所以比 HTTP 安全，是因为他**利用 SSL/TLS 协议传输**。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer 传递等。保障了传输过程的安全性

### TLS 协议加密

#### 相关概念

- **明文传输**：客户端发送请求，服务端发送响应，双方**都不对自己的请求/响应内容做加密**，一旦请求/响应被中间人拦截，就可以对其中的内容一览无余
- **对称加密**：客户端和服务器**约定一个共同的公钥**，加密和解密都依赖这个公钥，一旦公钥失窃，那么双方传输的密文信息就会暴露出来
- **非对称加密**：**公钥+私钥配合加密**，公钥与私钥是**多对一**的关系，公钥加密的内容，只有私钥能解开，私钥加密的内容，所有相关的公钥都可以解开，中间人截获了公钥也没办法解密数据，但**中间人可伪造公钥**
- **第三方认证**：第三方机构提供证书（Certificate Authority(CA)）
  - 包括：域名、公司信息、序列号、签名信息
  - 客户端里会维护一套**所有权威 CA 的公钥**用于解密
  - 客户端根据请求里证书的机构信息后，使用对应的公钥解析证书里的签名和服务器发来的公钥信息，用**解析的签名来校验对方的身份**，校验通过就使用公钥来进行通信

#### TLS 的四次握手

![image-20201113180036803](https://tva1.sinaimg.cn/large/0081Kckwgy1glx0yz8rotj317s0soaoy.jpg)

1. **客户端发送一个随机值**，需要的**协议和加密方式**
2. **服务端**收到客户端的随机值，自己也**产生一个随机值**，并根据客户端需求的**协议和加密方式**来使用对应的方式，**发送自己的证书**
3. **客户端**收到服务端的证书并**验证**是否有效，验证通过会再**生成一个随机值**，通过**服务端证书的公钥去加密这个随机值并发送给服务端**，如果服务端需要验证客户端证书的话会**附带证书**
4. **服务端**收到加密过的随机值并**使用私钥解密获得第三个随机值**，这时候**两端都拥有了三个随机值**，可以**通过这三个随机值按照之前约定的加密方式生成密钥**，接下来的通信就可以通过该密钥来加密解密

在 TLS 握手阶段，两端使用**非对称加密**的方式来通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用**对称加密**的方式通信
