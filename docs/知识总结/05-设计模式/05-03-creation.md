# 创建型模式

创建型模式关注**如何创建对象**，主要特点是将对象的创建和使用分离。一般抽象了对象实例化的过程，用来帮助创建对象的实例。

1. 单例模式： 保证一个类只有一个实例，并提供一个访问它的全局访问点；
2. 工厂模式： 根据输入的不同返回不同类的实例，一般用来创建同一类对象；
3. 抽象工厂模式： 通过对类的工厂抽象，使其业务用于对产品类簇的创建；
4. 建造者模式： 分步构建一个复杂对象，使得同样的构建过程可以采用不同的表示；

## 单例模式

> 保证一个类仅有一个实例，并提供一个访问它的全局访问点

**单例模式** （Singleton Pattern）又称为单体模式，保证一个类只有一个实例，并提供一个访问它的全局访问点。也就是说，第二次使用同一个类创建新对象的时候，应该得到与第一次创建的对象完全相同的对象。

编程中有很多对象我们只需要唯一一个，比如数据库连接、线程池、配置文件缓存、浏览器中的 window/document 等，如果创建多个实例，会带来资源耗费严重，或访问行为不一致等情况。

在类似场景中，这些例子有以下特点：

1. 每次访问者来访问，返回的都是同一个实例；
2. 如果一开始实例没有创建，那么这个特定类需要自行创建这个实例；

### 单例模式的通用实现

游戏可以被认为是一个特定的类（Singleton），而存档是单例（instance），每次访问特定类的时候，都会拿到同一个实例。主要有下面几个概念：

1. **Singleton**：特定类，这是我们需要访问的类，访问者要拿到的是它的实例；
2. **instance**：单例，是特定类的实例，特定类一般会提供 `getInstance` 方法来获取该单例；
3. **getInstance**：获取单例的方法，或者直接由 `new` 操作符获取；

这里有几个实现点要关注一下：

1. 访问时始终返回的是同一个实例；
2. 自行实例化，无论是一开始加载的时候就创建好，还是在第一次被访问时；
3. 一般还会提供一个 `getInstance` 方法用来获取它的实例；

结构大概如下图：

![图片描述](https://tva1.sinaimg.cn/large/008eGmZEgy1gnvay1j69mj30fn093q35.jpg)

#### 实现方式

1. IIFE 方式创建单例：IIFE 内部返回的 `Singleton` 才是我们真正需要的单例的构造函数，外部的 `Singleton` 把它和一些单例模式的创建逻辑进行了一些封装
2. ES6 的块级作用域方式创建单例：IIFE 方式本质还是通过函数作用域的方式来隐藏内部作用域的变量，有了 ES6 的 let/const 之后，可以通过 `{ }` 块级作用域的方式来隐藏内部变量
3. **代理类**：将业务类和单例模式的逻辑解耦，把单例的创建逻辑抽象封装出来，有利于业务类的扩展和维护
4. 使用 ES6 引入的 `Proxy` 来拦截默认的 `new` 方式

### 惰性单例、懒汉式-饿汉式

有时候一个实例化过程比较耗费性能的类，但是却一直用不到，如果一开始就对这个类进行实例化就显得有些浪费，那么这时我们就可以使用**惰性创建**，即延迟创建该类的单例。之前的例子都属于惰性单例，实例的创建都是 `new` 的时候才进行。

惰性单例又被成为**懒汉式**，相对应的概念是**饿汉式**：

- **懒汉式**单例是在使用时才实例化
- **饿汉式**是当程序启动时或单例模式类一加载的时候就被创建。

### 单例模式的优缺点

单例模式主要解决的问题就是**节约资源，保持访问一致性**。

简单分析一下它的优点：

1. 单例模式在创建后在内存中只存在一个实例，节约了内存开支和实例化时的性能开支，特别是需要重复使用一个创建开销比较大的类时，比起实例不断地销毁和重新实例化，单例能节约更多资源，比如数据库连接
2. 单例模式可以解决对资源的多重占用，比如写文件操作时，因为只有一个实例，可以避免对一个文件进行同时操作
3. 只使用一个实例，也可以减小垃圾回收机制 GC（Garbage Collecation） 的压力，表现在浏览器中就是系统卡顿减少，操作更流畅，CPU 资源占用更少

单例模式也是有缺点的

1. 单例模式对扩展不友好，一般**不容易扩展**，因为单例模式一般自行实例化，没有接口
2. **与单一职责原则冲突**，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化

### 单例模式的使用场景

那我们应该在什么场景下使用单例模式呢：

1. 当一个类的**实例化过程消耗的资源过多**，可以使用单例模式来避免性能浪费
2. 当项目中需要一个公共的状态，那么需要使用单例模式来**保证访问一致性**

## 工厂模式

> **工厂模式** （Factory Pattern），根据不同的输入返回不同类的实例，一般用来创建同一类对象。

工厂方式的主要思想是**将对象的创建与对象的实现分离**，因此有以下特点：

1. 访问者只需要知道产品名，就可以从工厂获得对应实例；
2. 访问者不关心实例创建过程；

例如:

- `document.createElement` 方法创建 DOM 元素，虽然这个方法实际上很复杂，但其使用的就是工厂方法的思想：访问者只需提供标签名（如 div、img），那么这个方法就会返回对应的 DOM 元素。
- Vue 和 React 这种具有虚拟 DOM 树（Virtual Dom Tree）机制的框架在生成虚拟 DOM 的时候，都提供了 `createElement` 方法用来生成 VNode，用来作为真实 DOM 节点的映射

```js
/* 饭店方法 */
class Restaurant {
  static getMenu(menu) {
    switch (menu) {
      case '鱼香肉丝':
        return new YuXiangRouSi();
      case '宫保鸡丁':
        return new GongBaoJiDin();
      default:
        throw new Error('这个菜本店没有 -。-');
    }
  }
}

/* 鱼香肉丝类 */
class YuXiangRouSi {
  constructor() {
    this.type = '鱼香肉丝';
  }

  eat() {
    console.log(this.type + ' 真香~');
  }
}

/* 宫保鸡丁类 */
class GongBaoJiDin {
  constructor() {
    this.type = '宫保鸡丁';
  }

  eat() {
    console.log(this.type + ' 让我想起了外婆做的菜~');
  }
}

const dish1 = Restaurant.getMenu('鱼香肉丝');
dish1.eat(); // 输出: 鱼香肉丝 真香~
const dish2 = Restaurant.getMenu('红烧排骨'); // 输出: Error 这个菜本店没有 -。-
```

这样就完成了一个工厂模式，但是这个实现有一个问题：工厂方法中包含了很多与创建产品相关的过程，如果产品种类很多的话，这个工厂方法中就会罗列很多产品的创建逻辑，每次新增或删除产品种类，不仅要增加产品类，还需要对应修改在工厂方法，违反了开闭原则，也导致这个工厂方法变得臃肿、高耦合。

严格上这种实现在面向对象语言中叫做**简单工厂模式**。适用于产品种类比较少，创建逻辑不复杂的时候使用。

**工厂模式**的本意是将实际创建对象的过程推迟到子类中，一般用抽象类来作为父类，创建过程由抽象类的子类来具体实现。JavaScript 中没有抽象类，所以我们可以简单地将工厂模式看做是一个实例化对象的工厂类即可。关于抽象类的有关内容，可以参看抽象工厂模式。

### 工厂模式的通用实现

根据上面的例子我们可以提炼一下工厂模式，饭店可以被认为是工厂类（Factory），菜品是产品（Product），如果我们希望获得菜品实例，通过工厂类就可以拿到产品实例，不用关注产品实例创建流程。主要有下面几个概念：

1. **Factory** ：工厂，负责返回产品实例；
2. **Product** ：产品，访问者从工厂拿到产品实例；

结构大概如下：

![图片描述](https://tva1.sinaimg.cn/large/008eGmZEgy1gnvmr5iqf3j30n60akmxp.jpg)
下面用通用的方法实现，这里直接用 class 语法：

```javascript
/* 工厂类 */
class Factory {
  static getInstance(type) {
    switch (type) {
      case 'Product1':
        return new Product1();
      case 'Product2':
        return new Product2();
      default:
        throw new Error('当前没有这个产品');
    }
  }
}

/* 产品类1 */
class Product1 {
  constructor() {
    this.type = 'Product1';
  }

  operate() {
    console.log(this.type);
  }
}

/* 产品类2 */
class Product2 {
  constructor() {
    this.type = 'Product2';
  }

  operate() {
    console.log(this.type);
  }
}

const prod1 = Factory.getInstance('Product1');
prod1.operate(); // 输出: Product1
const prod2 = Factory.getInstance('Product3'); // 输出: Error 当前没有这个产品
```

注意，由于 JavaScript 的灵活，简单工厂模式返回的产品对象不一定非要是类实例，也可以是字面量形式的对象，所以读者可以根据场景灵活选择返回的产品对象形式。

### 工厂模式的优缺点

工厂模式将**对象的创建和实现分离**，这带来了优点：

1. 良好的封装，代码结构清晰，**访问者无需知道对象的创建流程**，特别是创建比较复杂的情况下；
2. 扩展性优良，通过工厂方法隔离了用户和创建流程隔离，**符合开放封闭原则**；
3. 解耦了高层逻辑和底层产品类，**符合最少知识原则**，不需要的就不要去交流；

工厂模式的缺点：带来了**额外的系统复杂度**，增加了抽象性；

### 工厂模式的使用场景

那么什么时候使用工厂模式呢：

1. 对象的创建比较复杂，而访问者无需知道创建的具体流程；
2. 处理大量具有相同属性的小对象；

什么时候不该用工厂模式：滥用只是增加了不必要的系统复杂度，过犹不及。

### 其他相关模式

#### 工厂模式与抽象工厂模式

这两个方式可以组合使用，具体联系与区别在抽象工厂模式中讨论

#### 工厂模式与模板方法模式

这两个模式看起来比较类似，不过主要区别是：

1. **工厂模式**主要关注产品实例的创建，对创建流程封闭起来；
2. **模板方法模式**主要专注的是为固定的算法骨架提供某些步骤的实现；

这两个模式也可以组合一起来使用，比如在模板方法模式里面，使用工厂方法来创建模板方法需要的对象。

## 抽象工厂模式

**抽象工厂**（Abstract Factory）：通过对类的工厂抽象使其业务用于对产品类簇的创建，而不是负责创建某一类产品的实例。关键在于使用抽象类制定了实例的结构，调用者直接面向实例的结构编程，**从实例的具体实现中解耦**。

我们知道 JavaScript 并不是强面向对象语言，所以使用传统编译型语言比如 JAVA、C#、C++ 等实现的设计模式和 JavaScript 不太一样，比如 JavaScript 中没有原生的类和接口等（不过 ES6+ 渐渐提供类似的语法糖），我们可以用变通的方式来解决。最重要的是设计模式背后的核心思想，和它所要解决的问题。

### 生活中例子

你来了小区的饭店，跟老板说来一份鱼香肉丝，来一份宫保鸡丁，来一份番茄鸡蛋汤，来一份排骨汤。无论什么样的菜，还是什么样的汤，他们都具有同样的属性，比如菜都可以吃，汤都可以喝。所以我们不论拿到什么菜，都可以吃，而不论拿到什么汤，都可以喝。对于饭店也一样，这个饭店可以做菜做汤，另一个饭店也可以，那么这两个饭店就具有同样的功能结构。

上面的场景都是属于抽象工厂模式的例子。菜类属于抽象产品类，制定具体产品菜类所具备的属性，而饭店和之前的工厂模式一样，负责具体生产产品实例，访问者通过老板获取想拿的产品。只要我们点的是汤类，即使还没有被做出来，我们就知道是可以喝的。推广一下，饭店功能也可以被抽象（抽象饭店类），继承这个类的饭店实例都具有做菜和做汤的功能，这样也完成了抽象类对实例的结构约束。

在类似场景中，这些例子有特点：**只要实现了抽象类的实例，都实现了抽象类制定的结构**；

### 抽象工厂模式的通用实现

我们提炼一下抽象工厂模式，饭店还是工厂（Factory），菜品种类是抽象类（AbstractFactory），而实现抽象类的菜品是具体的产品（Product），通过工厂拿到实现了不同抽象类的产品，这些产品可以根据实现的抽象类被区分为类簇。主要有下面几个概念：

1. **Factory** ：工厂，负责返回产品实例；
2. **AbstractFactory** ：虚拟工厂，制定工厂实例的结构；
3. **Product** ：产品，访问者从工厂中拿到的产品实例，实现抽象类；
4. **AbstractProduct** ：产品抽象类，由具体产品实现，制定产品实例的结构；

概略图如下：

![图片描述](https://tva1.sinaimg.cn/large/008eGmZEgy1gnvn3cw1zdj30w70d00u5.jpg)
下面是通用的实现，原型方式略过：

```javascript
/* 工厂 抽象类 */
class AbstractFactory {
  constructor() {
    if (new.target === AbstractFactory)
      throw new Error('抽象类不能直接实例化!');
  }

  /* 抽象方法 */
  createProduct1() {
    throw new Error('抽象方法不能调用!');
  }
}

/* 具体饭店类 */
class Factory extends AbstractFactory {
  constructor() {
    super();
  }

  createProduct1(type) {
    switch (type) {
      case 'Product1':
        return new Product1();
      case 'Product2':
        return new Product2();
      default:
        throw new Error('当前没有这个产品 -。-');
    }
  }
}

/* 抽象产品类 */
class AbstractProduct {
  constructor() {
    if (new.target === AbstractProduct)
      throw new Error('抽象类不能直接实例化!');
    this.kind = '抽象产品类1';
  }

  /* 抽象方法 */
  operate() {
    throw new Error('抽象方法不能调用!');
  }
}

/* 具体产品类1 */
class Product1 extends AbstractProduct {
  constructor() {
    super();
    this.type = 'Product1';
  }

  operate() {
    console.log(this.kind + ' - ' + this.type);
  }
}

/* 具体产品类2 */
class Product2 extends AbstractProduct {
  constructor() {
    super();
    this.type = 'Product2';
  }

  operate() {
    console.log(this.kind + ' - ' + this.type);
  }
}

const factory = new Factory();

const prod1 = factory.createProduct1('Product1');
prod1.operate(); // 输出: 抽象产品类1 - Product1
const prod2 = factory.createProduct1('Product3'); // 输出: Error 当前没有这个产品 -。-
```

如果希望增加第二个类簇的产品，除了需要改一下对应工厂类之外，还需要增加一个抽象产品类，并在抽象产品类基础上扩展新的产品。

我们在实际使用的时候不一定需要每个工厂都继承抽象工厂类，比如只有一个工厂的话我们可以直接使用工厂模式，在实战中灵活使用。

## 4. 抽象工厂模式的优缺点

抽象模式的优点：抽象产品类将产品的结构抽象出来，访问者不需要知道产品的具体实现，只需要面向产品的结构编程即可，**从产品的具体实现中解耦**；

抽象模式的缺点：

1. **扩展新类簇的产品类比较困难**，因为需要创建新的抽象产品类，并且还要修改工厂类，违反开闭原则；
2. 带来了**系统复杂度**，增加了新的类，和新的继承关系；

## 5. 抽象工厂模式的使用场景

如果一组实例都有相同的结构，那么就可以使用抽象工厂模式。

## 6. 其他相关模式

### 6.1 抽象工厂模式与工厂模式

工厂模式和抽象工厂模式的区别：

1. **工厂模式**主要关注单独的产品实例的创建；
2. **抽象工厂模式**主要关注产品类簇实例的创建，如果产品类簇只有一个产品，那么这时的抽象工厂模式就退化为工厂模式了；

根据场景灵活使用即可。
