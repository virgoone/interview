# 浏览器渲染原理

## 浏览器架构

![image-20201105194356183](https://tva1.sinaimg.cn/large/008eGmZEgy1gn5q7ohnlkj31pc0qk41t.jpg)

在 Chrome 中，主要的进程有 4 个：

1. **浏览器主进程**：主要负责**界面显示**、**用户交互**、子进程管理，同时提供存储功能，例如：浏览器 TAB 的前进、后退、地址栏、书签栏等
2. **渲染进程**：核心任务是**将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页**。**排版引擎 Blink** 和 **JS 引擎 V8** 都是运行在该进程中，默认情况下，Chrome 会为**每个 Tab 标签创建一个渲染进程**。出于安全考虑，渲染进程都是运行在沙盒中
3. **GPU 进程**：（最初没有）处理浏览器的 GPU 任务
4. **网络进程**：（之前在主进程中）负责页面的**网络资源加载**
5. **插件进程**：负责**插件的运行**，控制网页中使用到的插件

### 进程之间的关系

1. 首先，在浏览器的地址栏里输入 URL，这时**浏览器进程**会让**网络进程**向这个 URL 发送请求，获取这个 URL 的 HTML 内容，然后将 HTML 交给**渲染进程**
2. **渲染进程**解析 HTML 内容，解析遇到需要请求网络的资源就通知**浏览器进程**交给**网络进程**，同时通知**插件进程**加载插件资源，执行插件代码
3. 解析完成后，**渲染进程**计算得到图像帧，并将这些图像帧交给**GPU 进程**，**GPU 进程**将其转化为图像显示屏幕。

![进程关系](https://tva1.sinaimg.cn/large/008eGmZEgy1gn5q7eb80uj31cq0u0tl8.jpg)

### 多进程架构好处

1. **更高的容错性**：多进程架构使得每一个渲染引擎运行在各自的进程中，相互之间不受影响。也就是说，一个页面挂掉之后，其他页面还可以正常的运行不受影响。
2. **更高的安全性和沙盒性**：渲染引擎会经常性在网络上遇到不可信或恶意代码，针对这一问题，浏览器对不同进程限制了不同权限，并为其提供沙盒运行环境，使其更安全可靠
3. **更高的响应速度**：单进程架构中，各个任务相互竞争抢夺 CPU 资源，使得浏览器响应速度变慢，多进程架构可以规避这个问题

## 浏览器渲染流程

### 渲染流水线

1. **构建 DOM 树**：渲染进程将 HTML 转换为浏览器能够理解的 **DOM 树**结构
2. **样式计算**：渲染引擎将 CSS 样式表转化为浏览器能够理解的 **styleSheets 样式表**，计算出 DOM 节点的样式
3. **布局阶段**：创建布局树，并计算元素的布局信息
4. **分层**：对布局树进行分层，并生成**布局树**
5. **绘制**：为每个图层生成**绘制列表**，并将其提交给合成线程
6. **分块**：合成线程将图成分成**图块**
7. **光栅化**：在**光栅化线程池**中将图块转换成位图
8. **合成及显示**：合成线程发送绘制图块命令 `DrowQuad` 给浏览器进程，浏览器进程根据 `DrawQuad` 消息**生成页面**，并显示到屏幕上

### 1. 构建 DOM 树

因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构 —— **DOM 树**

DOM 和 HTML 内容基本是一样的，但不同的是，DOM 是保存在内存中的树状结构，可以通过 JavaScript 来查询或修改其内容。

### 2. 样式计算

样式计算的目的是为了**计算出 DOM 节点中每个元素的具体样式**，这个阶段大体可分为三步来完成：

1. **把 CSS 转换为浏览器能够理解的结构**：当**渲染引擎**接受到 CSS 文本时，会将其转换为浏览器可以理解的 **styleSheets**（样式表）结构。
2. **转换样式表中的属性值，使其标准化**：将所有值（`em`, `red`, `bold` 等）转换为**渲染引擎**容易理解的、标准化的值
3. **计算出 DOM 树中每个节点的具体样式**：CSS 的**继承性**和**层叠性**

CSS 样式的三种来源：

- 通过 `link` 引用的外部 CSS 文件
- `<style>` 标记内部的 CSS
- 元素的 `style` 属性内嵌的 CSS

### 3. 布局阶段

现在还不知道 DOM 元素的几何位置，所以无法显示页面。布局阶段就要**计算出 DOM 树中可见元素的几何位置**。Chrome 在布局阶段需要完成两个任务：**创建布局树**和**布局计算**。

1. **创建布局树**：剔除掉不可见的 DOM 元素，额外构建一棵**只包含可见元素的布局树**。
2. **布局计算**：计算布局树中节点的**坐标位置**

### 4. 分层

因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 `z-index` 做 z 轴排序等，为了更加方便地实现这些效果，**渲染引擎还需要为特定的节点生成专用的图层，并生成一个对应的图层树**（LayerTree）

浏览器的页面实际被分为了很多图层，这些图层叠加后合成了最终的页面。

创建新图层的条件：

1. 拥有**层叠上下文属性**（`position`, `z-index`, `opacity`, `filter`）的元素会被提升为单独的一层
2. 需要**剪裁**（clip）的地方也会被创建为图层

### 5. 图层绘制

渲染引擎会把一个图层的绘制拆分成很多小的**绘制指令**，再把这些指令按照顺序组成一个待绘制列表。

### 6. 栅格化操作

绘制列表的实际绘制操作是由**渲染引擎的合成线程**来完成的。当绘制列表准备完毕后，主线程会把该绘制列表**提交（commit）**给合成线程

合成线程会将图层划分为**图块**（tile），并按照**视口附近的图块优先的原则**来生成位图，而实际生成位图的操作是由**栅格化**来执行的。所谓**栅格化**，就是指**将图块转换为位图**，而图块是栅格化执行的最小单位。

通常，栅格化过程都会使用 GPU 来加速生生成，这叫做**快速栅格化**或 **GPU 栅格化**。

### 7. 合成和显示

一旦所有图块都被光栅化，合成线程就会**生成一个绘制图块的 `DrowQuad` 命令，并提交给浏览器进程**，然后浏览器根据消息生成页面并显示到屏幕上
